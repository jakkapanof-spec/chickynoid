local framework = require("../lib/framework")
local Loader = require("../lib/loader")

local describe = framework.describe
local it = framework.it
local expect = framework.expect

local Vector3 = Loader.Vector3

local WriteBuffer = Loader.load("src/ReplicatedFirst/Packages/Chickynoid/Shared/Vendor/WriteBuffer.lua")

describe("WriteBuffer.new", function()
    it("creates a buffer with default size", function()
        local wb = WriteBuffer.new()
        expect(wb).toBeTruthy()
        expect(wb.offset).toBe(0)
    end)

    it("creates a buffer with specified start size", function()
        local wb = WriteBuffer.new(64)
        expect(wb).toBeTruthy()
        expect(wb.startSize).toBe(64)
    end)
end)

describe("WriteBuffer:WriteU8", function()
    it("writes a single byte and advances offset", function()
        local wb = WriteBuffer.new()
        wb:WriteU8(42)
        expect(wb.offset).toBe(1)
    end)

    it("writes correct value readable via buffer API", function()
        local wb = WriteBuffer.new()
        wb:WriteU8(255)
        local buf = wb:GetBuffer()
        expect(buffer.readu8(buf, 0)).toBe(255)
    end)
end)

describe("WriteBuffer:WriteI16", function()
    it("writes a 16-bit value and advances offset by 2", function()
        local wb = WriteBuffer.new()
        wb:WriteI16(1234)
        expect(wb.offset).toBe(2)
    end)

    it("writes correct value readable via buffer API", function()
        local wb = WriteBuffer.new()
        wb:WriteI16(5678)
        local buf = wb:GetBuffer()
        expect(buffer.readu16(buf, 0)).toBe(5678)
    end)
end)

describe("WriteBuffer:WriteVector3", function()
    it("writes 3 floats and advances offset by 12", function()
        local wb = WriteBuffer.new()
        wb:WriteVector3(Vector3.new(1, 2, 3))
        expect(wb.offset).toBe(12)
    end)

    it("writes correct x, y, z values", function()
        local wb = WriteBuffer.new()
        wb:WriteVector3(Vector3.new(1.5, 2.5, 3.5))
        local buf = wb:GetBuffer()
        expect(buffer.readf32(buf, 0)).toBeCloseTo(1.5)
        expect(buffer.readf32(buf, 4)).toBeCloseTo(2.5)
        expect(buffer.readf32(buf, 8)).toBeCloseTo(3.5)
    end)
end)

describe("WriteBuffer:WriteFloat16", function()
    it("advances offset by 2", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(1.0)
        expect(wb.offset).toBe(2)
    end)

    it("handles zero", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(0)
        local buf = wb:GetBuffer()
        expect(buffer.readu8(buf, 0)).toBe(0)
        expect(buffer.readu8(buf, 1)).toBe(0)
    end)

    it("handles positive infinity", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(math.huge)
        expect(wb.offset).toBe(2)
    end)

    it("handles negative values", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(-1.0)
        local buf = wb:GetBuffer()
        -- Sign bit should be set (first byte has 0x80 bit set)
        local b0 = buffer.readu8(buf, 0)
        expect(bit32.btest(b0, 128)).toBe(true)
    end)
end)

describe("WriteBuffer:GetBuffer", function()
    it("returns a buffer trimmed to actual written size", function()
        local wb = WriteBuffer.new(128) -- start with large buffer
        wb:WriteU8(1)
        wb:WriteU8(2)
        wb:WriteU8(3)
        local buf = wb:GetBuffer()
        expect(buffer.len(buf)).toBe(3)
    end)

    it("returns same buffer when size matches offset", function()
        local wb = WriteBuffer.new(0)
        wb:WriteU8(1)
        local buf1 = wb:GetBuffer()
        local buf2 = wb:GetBuffer()
        -- After first GetBuffer, buffer is trimmed; second call returns same
        expect(buffer.len(buf2)).toBe(1)
    end)
end)

describe("WriteBuffer:CheckSize", function()
    it("auto-grows the buffer when writing beyond initial size", function()
        local wb = WriteBuffer.new(1)
        -- Write more than 1 byte
        wb:WriteU8(1)
        wb:WriteU8(2)
        wb:WriteU8(3)
        expect(wb.offset).toBe(3)
        expect(wb.currentSize).toBeGreaterThan(1)
    end)

    it("preserves existing data when growing", function()
        local wb = WriteBuffer.new(1)
        wb:WriteU8(42)
        wb:WriteU8(99) -- triggers growth
        local buf = wb:GetBuffer()
        expect(buffer.readu8(buf, 0)).toBe(42)
        expect(buffer.readu8(buf, 1)).toBe(99)
    end)
end)

describe("WriteBuffer sequential writes", function()
    it("correctly handles multiple mixed writes", function()
        local wb = WriteBuffer.new()
        wb:WriteU8(1)
        wb:WriteI16(2)
        wb:WriteVector3(Vector3.new(3, 4, 5))
        expect(wb.offset).toBe(1 + 2 + 12)
    end)
end)
