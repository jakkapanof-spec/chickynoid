local framework = require("../lib/framework")
local Loader = require("../lib/loader")

local describe = framework.describe
local it = framework.it
local expect = framework.expect

local Vector3 = Loader.Vector3

local WriteBuffer = Loader.load("src/ReplicatedFirst/Packages/Chickynoid/Shared/Vendor/WriteBuffer.lua")
local ReadBuffer = Loader.load("src/ReplicatedFirst/Packages/Chickynoid/Shared/Vendor/ReadBuffer.lua")

describe("ReadBuffer.new", function()
    it("creates a reader wrapping a buffer", function()
        local buf = buffer.create(10)
        local rb = ReadBuffer.new(buf)
        expect(rb).toBeTruthy()
        expect(rb.offset).toBe(0)
    end)
end)

describe("ReadBuffer:ResetReadPos", function()
    it("resets offset to 0", function()
        local buf = buffer.create(10)
        buffer.writeu8(buf, 0, 42)
        local rb = ReadBuffer.new(buf)
        rb:ReadU8()
        expect(rb.offset).toBe(1)
        rb:ResetReadPos()
        expect(rb.offset).toBe(0)
    end)

    it("allows re-reading the same data", function()
        local buf = buffer.create(1)
        buffer.writeu8(buf, 0, 42)
        local rb = ReadBuffer.new(buf)
        local first = rb:ReadU8()
        rb:ResetReadPos()
        local second = rb:ReadU8()
        expect(first).toBe(second)
    end)
end)

describe("WriteBuffer + ReadBuffer roundtrip", function()
    it("roundtrips U8 values", function()
        local wb = WriteBuffer.new()
        wb:WriteU8(0)
        wb:WriteU8(127)
        wb:WriteU8(255)
        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadU8()).toBe(0)
        expect(rb:ReadU8()).toBe(127)
        expect(rb:ReadU8()).toBe(255)
    end)

    it("roundtrips I16 values", function()
        local wb = WriteBuffer.new()
        wb:WriteI16(0)
        wb:WriteI16(1234)
        wb:WriteI16(65535)
        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadI16()).toBe(0)
        expect(rb:ReadI16()).toBe(1234)
        expect(rb:ReadI16()).toBe(65535)
    end)

    it("roundtrips Vector3 values", function()
        local wb = WriteBuffer.new()
        wb:WriteVector3(Vector3.new(1.5, -2.5, 3.5))
        local rb = ReadBuffer.new(wb:GetBuffer())
        local result = rb:ReadVector3()
        expect(result.X).toBeCloseTo(1.5)
        expect(result.Y).toBeCloseTo(-2.5)
        expect(result.Z).toBeCloseTo(3.5)
    end)

    it("roundtrips Float16 values with acceptable precision", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(1.0)
        wb:WriteFloat16(-1.0)
        wb:WriteFloat16(0.5)
        wb:WriteFloat16(100.0)
        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadFloat16()).toBeCloseTo(1.0, 0.01)
        expect(rb:ReadFloat16()).toBeCloseTo(-1.0, 0.01)
        expect(rb:ReadFloat16()).toBeCloseTo(0.5, 0.01)
        expect(rb:ReadFloat16()).toBeCloseTo(100.0, 1.0)
    end)

    it("roundtrips Float16 zero", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(0)
        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadFloat16()).toBeCloseTo(0)
    end)

    it("roundtrips Float16 infinity", function()
        local wb = WriteBuffer.new()
        wb:WriteFloat16(math.huge)
        wb:WriteFloat16(-math.huge)
        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadFloat16()).toBe(math.huge)
        expect(rb:ReadFloat16()).toBe(-math.huge)
    end)

    it("roundtrips a sequence of mixed writes and reads", function()
        local wb = WriteBuffer.new()
        wb:WriteU8(42)
        wb:WriteI16(1234)
        wb:WriteVector3(Vector3.new(10, 20, 30))
        wb:WriteFloat16(5.0)
        wb:WriteU8(99)

        local rb = ReadBuffer.new(wb:GetBuffer())
        expect(rb:ReadU8()).toBe(42)
        expect(rb:ReadI16()).toBe(1234)
        local v = rb:ReadVector3()
        expect(v.X).toBeCloseTo(10)
        expect(v.Y).toBeCloseTo(20)
        expect(v.Z).toBeCloseTo(30)
        expect(rb:ReadFloat16()).toBeCloseTo(5.0, 0.1)
        expect(rb:ReadU8()).toBe(99)
    end)
end)
